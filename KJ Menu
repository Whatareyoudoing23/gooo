local WhitelistedUsers = {2744508863, 10065223547, 10025846437, 9831122417, 10079932558, 4828370601, 10135112207, 9672761750, 10153776356, 7858895618, 9019542633, 10156286117, 10162695973, 4124084908, 10126819232, 10133877006, 10134789090, 6183380699, 8652280189, 5132474449, 10032618163, 10310778140, 10344244339, 8898287716, 10363397680}
-- [My Alt]
-- [KyRi]
-- [Jah]
-- [MICHALLLLL627]
-- [1gkxd]
-- [BIGZOOKSAB]
-- [NOOB_SPAREME]
-- [IH8CRAZY_ALTTT]
-- [J5KILLLEM]
-- [Therealli61]
-- [bxltAltacc]
-- [RIRI_Account4]
-- [unknown_sfgodinN]
-- [Bleeod2]
-- [iSwipeWigs]
-- [ippuller5]
-- [forgetHumbleWeflex]
-- [A3cention]
-- [Jahkuba13]
-- [wxkdothralt]
-- [wxkddds] 
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local player = Players.LocalPlayer
if not table.find(WhitelistedUsers, player.UserId) then
    player:Kick("\nLOL You're not whitelisted NK.\nDM KJ on Discord to buy")
    repeat task.wait() until false
end
local repo = "https://raw.githubusercontent.com/deividcomsono/Obsidian/main/"
local Library = loadstring(game:HttpGet(repo.."Library.lua"))()
local ThemeManager = loadstring(game:HttpGet(repo.."addons/ThemeManager.lua"))()
local SaveManager = loadstring(game:HttpGet(repo.."addons/SaveManager.lua"))()
local Window = Library:CreateWindow({
    Title = "KJ's Menu",
    Footer = "Made by KJ",
    NotifySide = "Right",
    ShowCustomCursor = true,
})
local Tabs = {
    Combat = Window:AddTab("Combat", "sword"), -- âš”ï¸ Sword icon
    Misc = Window:AddTab("Misc", "package"), -- ðŸ“¦ Package/Block-like
    Farming = Window:AddTab("Farming", "wheat"), -- ðŸŒ¾ Wheat icon (perfect for farming)
    Playerlist = Window:AddTab("Playerlist", "users"), -- ðŸ‘¥ Multiple users icon
    Spawn = Window:AddTab("Spawn", "map-pin"), -- ðŸ“ Location pin
    Config = Window:AddTab("Config", "settings"), -- âš™ï¸ Gear/Settings icon
}
-- ====================== FLY + COMPOUND V ANIMATION (LOOKS INSANE) ======================
local FlyEnabled = false
local FlyConnection = nil
local FlySpeed = 100
local FlyBodyGyro = nil
local FlyBodyVelocity = nil
local FlyKeys = {W = false, S = false, A = false, D = false, Space = false, LeftControl = false}
local CompoundVTrack = nil
local COMPOUND_V_ANIM_ID = 18449056925 -- Compound V floating animation
local function PlayCompoundV()
    if not player.Character or not player.Character:FindFirstChild("Humanoid") then return end
    local hum = player.Character.Humanoid
    -- Stop any current animation
    if CompoundVTrack and CompoundVTrack.IsPlaying then CompoundVTrack:Stop() end
    local anim = Instance.new("Animation")
    anim.AnimationId = "rbxassetid://" .. COMPOUND_V_ANIM_ID
    CompoundVTrack = hum:LoadAnimation(anim)
    CompoundVTrack.Priority = Enum.AnimationPriority.Action4
    CompoundVTrack.Looped = true
    CompoundVTrack:Play()
end
local function StopCompoundV()
    if CompoundVTrack and CompoundVTrack.IsPlaying then
        CompoundVTrack:Stop()
        CompoundVTrack = nil
    end
end
local function StartFly()
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return end
    local hrp = player.Character.HumanoidRootPart
    local hum = player.Character:FindFirstChildOfClass("Humanoid")
    if not hum then return end
    hum.PlatformStand = true
    -- Start Compound V animation
    PlayCompoundV()
    FlyBodyGyro = Instance.new("BodyGyro")
    FlyBodyGyro.P = 9000
    FlyBodyGyro.MaxTorque = Vector3.new(9000, 9000, 9000)
    FlyBodyGyro.CFrame = hrp.CFrame
    FlyBodyGyro.Parent = hrp
    FlyBodyVelocity = Instance.new("BodyVelocity")
    FlyBodyVelocity.Velocity = Vector3.new(0, 0, 0)
    FlyBodyVelocity.MaxForce = Vector3.new(9000, 9000, 9000)
    FlyBodyVelocity.Parent = hrp
    FlyConnection = RunService.RenderStepped:Connect(function()
        if not FlyEnabled or not hrp or not hrp.Parent then return end
        local cam = workspace.CurrentCamera
        local moveDirection = Vector3.new(0, 0, 0)
        if FlyKeys.W then moveDirection = moveDirection + cam.CFrame.LookVector end
        if FlyKeys.S then moveDirection = moveDirection - cam.CFrame.LookVector end
        if FlyKeys.A then moveDirection = moveDirection - cam.CFrame.RightVector end
        if FlyKeys.D then moveDirection = moveDirection + cam.CFrame.RightVector end
        if FlyKeys.Space then moveDirection = moveDirection + Vector3.new(0, 1, 0) end
        if FlyKeys.LeftControl then moveDirection = moveDirection - Vector3.new(0, 1, 0) end
        if moveDirection.Magnitude > 0 then
            moveDirection = moveDirection.Unit
            FlyBodyVelocity.Velocity = moveDirection * FlySpeed
            FlyBodyGyro.CFrame = cam.CFrame
        else
            FlyBodyVelocity.Velocity = Vector3.new(0, 0, 0)
        end
    end)
    Library:Notify("FLY | Speed: "..FlySpeed, 6)
end
local function StopFly()
    if FlyConnection then FlyConnection:Disconnect() FlyConnection = nil end
    if FlyBodyGyro and FlyBodyGyro.Parent then FlyBodyGyro:Destroy() end
    if FlyBodyVelocity and FlyBodyVelocity.Parent then FlyBodyVelocity:Destroy() end
    if player.Character and player.Character:FindFirstChildOfClass("Humanoid") then
        player.Character:FindFirstChildOfClass("Humanoid").PlatformStand = false
    end
    StopCompoundV()
    Library:Notify("Fly", 3)
end
-- Keybinds (unchanged)
game:GetService("UserInputService").InputBegan:Connect(function(input, gp)
    if gp then return end
    if input.KeyCode == Enum.KeyCode.W then FlyKeys.W = true end
    if input.KeyCode == Enum.KeyCode.S then FlyKeys.S = true end
    if input.KeyCode == Enum.KeyCode.A then FlyKeys.A = true end
    if input.KeyCode == Enum.KeyCode.D then FlyKeys.D = true end
    if input.KeyCode == Enum.KeyCode.Space then FlyKeys.Space = true end
    if input.KeyCode == Enum.KeyCode.LeftControl then FlyKeys.LeftControl = true end
end)
game:GetService("UserInputService").InputEnded:Connect(function(input)
    if input.KeyCode == Enum.KeyCode.W then FlyKeys.W = false end
    if input.KeyCode == Enum.KeyCode.S then FlyKeys.S = false end
    if input.KeyCode == Enum.KeyCode.A then FlyKeys.A = false end
    if input.KeyCode == Enum.KeyCode.D then FlyKeys.D = false end
    if input.KeyCode == Enum.KeyCode.Space then FlyKeys.Space = false end
    if input.KeyCode == Enum.KeyCode.LeftControl then FlyKeys.LeftControl = false end
end)
player.CharacterAdded:Connect(function()
    task.wait(1.5)
    if FlyEnabled then
        StartFly()
    end
end)
-- UI - Fly in Misc Tab
local FlyBox = Tabs.Misc:AddLeftGroupbox("Fly")
FlyBox:AddToggle("FlyToggle", {
    Text = "Enable",
    Default = false,
    Callback = function(state)
        FlyEnabled = state
        if state then StartFly() else StopFly() end
    end
})
FlyBox:AddSlider("FlySpeed", {
    Text = "Fly Speed",
    Min = 16,
    Max = 500,
    Default = 120,
    Rounding = 1,
    Suffix = " studs/s",
    Callback = function(v)
        FlySpeed = v
        Library:Notify("Fly Speed â†’ "..v, 2)
    end
})
-- ====================== REAL-TIME PLAYERLIST (JOIN/LEAVE + NOTIFY) ======================
local SelectedPlayerDropdown = nil
local IgnoredDropdown = nil
local ignoredPlayers = {}
local NotifyJoinLeave = true -- This controls the notifications
local function formatPlayer(plr)
    return plr.DisplayName .. " (@" .. plr.Name .. ")"
end
local function getPlayerList()
    local list = {}
    for _, p in Players:GetPlayers() do
        if p ~= player then
            table.insert(list, formatPlayer(p))
        end
    end
    table.sort(list, function(a, b)
        return a:lower() < b:lower()
    end)
    return list
end
local function refreshDropdowns()
    local list = getPlayerList()
    -- Clean ignoredPlayers table of players who left
    for i = #ignoredPlayers, 1, -1 do
        local plr = ignoredPlayers[i]
        if not plr or not plr.Parent then
            table.remove(ignoredPlayers, i)
        end
    end
    -- Rebuild ignored selections
    local currentIgnoredValues = {}
    for _, plr in ipairs(ignoredPlayers) do
        table.insert(currentIgnoredValues, formatPlayer(plr))
    end
    -- === SELECT PLAYER DROPDOWN (Obsidian) ===
    if SelectedPlayerDropdown and SelectedPlayerDropdown.SetValues then
        SelectedPlayerDropdown:SetValues(list)
        -- Clear selection if selected player left
        local current = SelectedPlayerDropdown.Value
        if current and not table.find(list, current) then
            SelectedPlayerDropdown:SetValue(nil)
        end
    end
    -- === IGNORED PLAYERS DROPDOWN (Obsidian) ===
    if IgnoredDropdown and IgnoredDropdown.SetValues then
        IgnoredDropdown:SetValues(list)
        IgnoredDropdown:SetValue(currentIgnoredValues)
    end
end
-- Player joined
Players.PlayerAdded:Connect(function(plr)
    if plr ~= player then
        task.wait(0.3)
        refreshDropdowns()
        if NotifyJoinLeave then
            Library:Notify(plr.DisplayName .. " joined the game", 4)
        end
    end
end)
-- Player left
Players.PlayerRemoving:Connect(function(plr)
    if plr ~= player then
        refreshDropdowns()
        if NotifyJoinLeave then
            Library:Notify(plr.DisplayName .. " left the game", 4)
        end
    end
end)
local function getPlayerFromString(str)
    if not str or str == "" then return nil end
    local display, username = string.match(str, "(.+) %(@(.+)%)")
    if not display or not username then return nil end
    for _, plr in Players:GetPlayers() do
        if plr.DisplayName == display and plr.Name == username then
            return plr
        end
    end
    return nil
end
-- === UI ELEMENTS ===
local PlayerlistBox = Tabs.Playerlist:AddLeftGroupbox("Teleport & Follow")
-- Join/Leave Notification Toggle
PlayerlistBox:AddToggle("JoinLeaveNotifyToggle", {
    Text = "Join/Leave Notifications",
    Default = true,
    Callback = function(state)
        NotifyJoinLeave = state
        Library:Notify("Join/Leave Notifications: " .. (state and "ON" or "OFF"), 3)
    end
})
SelectedPlayerDropdown = PlayerlistBox:AddDropdown("SelectedPlayer", {
    Values = getPlayerList(),
    Text = "Select Player",
    Multi = false
})
local SettingsBox = Tabs.Playerlist:AddRightGroupbox("Player Settings")
IgnoredDropdown = SettingsBox:AddDropdown("IgnoredPlayers", {
    Values = getPlayerList(),
    Text = "Ignored Players",
    Multi = true,
    Callback = function(values)
        ignoredPlayers = {}
        for _, val in values do
            local plr = getPlayerFromString(val)
            if plr then
                table.insert(ignoredPlayers, plr)
            end
        end
    end
})
-- === INIT ===
Library:Notify("Playerlist script loaded", 5)
refreshDropdowns()
-- Periodic safety refresh
task.spawn(function()
    while task.wait(3) do
        refreshDropdowns()
    end
end)
player.CharacterAdded:Connect(function()
    task.wait(2)
    refreshDropdowns()
end)
Library:Notify("Playerlist + Notify Toggle Ready", 5)
-- ====================== PLAYER CYCLE TELEPORT (with return to original pos) ======================
local cycleTeleportEnabled = false
local cycleConnection = nil
local originalPosition = nil
local playerRoots = {}
local currentIndex = 1
local lastRefresh = 0

local BEHIND_DISTANCE = 1.2
local TELEPORT_DELAY = 0.16   -- time spent behind each player

local lastTeleportTime = 0

local function refreshPlayerCycleList()
    playerRoots = {}
    for _, plr in Players:GetPlayers() do
        if plr ~= player and plr.Character then
            local root = plr.Character:FindFirstChild("HumanoidRootPart")
            if root then
                table.insert(playerRoots, root)
            end
        end
    end
end

local function teleportBehindNext()
    if #playerRoots == 0 then return end

    local now = tick()
    if now - lastTeleportTime < TELEPORT_DELAY then
        return
    end

    currentIndex = currentIndex + 1

    -- Finished full cycle â†’ snap home instantly & reset
    if currentIndex > #playerRoots then
        if originalPosition and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            player.Character.HumanoidRootPart.CFrame = originalPosition
        end
        currentIndex = 1
        lastTeleportTime = now
        return
    end

    local targetRoot = playerRoots[currentIndex]

    if targetRoot and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        local hrp = player.Character.HumanoidRootPart
        local lookVector = targetRoot.CFrame.LookVector
        local behindPos = targetRoot.Position - (lookVector * BEHIND_DISTANCE)
        local newCFrame = CFrame.new(behindPos, behindPos + lookVector)
        
        hrp.CFrame = newCFrame
        lastTeleportTime = now
    end
end

local function startCycleTeleport()
    if cycleTeleportEnabled then return end
    
    local char = player.Character
    if not char or not char:FindFirstChild("HumanoidRootPart") then
        return
    end

    originalPosition = char.HumanoidRootPart.CFrame
    cycleTeleportEnabled = true
    currentIndex = 0  -- will become 1 on first real teleport
    lastRefresh = tick()
    lastTeleportTime = tick() - TELEPORT_DELAY

    refreshPlayerCycleList()

    cycleConnection = RunService.Heartbeat:Connect(function()
        local now = tick()
        
        if now - lastRefresh > 0.25 then
            refreshPlayerCycleList()
            lastRefresh = now
        end
        
        if cycleTeleportEnabled then
            teleportBehindNext()
        end
    end)
end

local function stopCycleTeleport()
    if not cycleTeleportEnabled then return end
    
    cycleTeleportEnabled = false
    if cycleConnection then
        cycleConnection:Disconnect()
        cycleConnection = nil
    end
    
    if originalPosition and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        player.Character.HumanoidRootPart.CFrame = originalPosition
    end
end

-- Button
SettingsBox:AddButton("Kill all", function()
    if cycleTeleportEnabled then
        stopCycleTeleport()
    else
        startCycleTeleport()
    end
end)

-- Respawn handling
player.CharacterAdded:Connect(function(newChar)
    task.wait(0.5)
    if cycleTeleportEnabled then
        stopCycleTeleport()
        task.delay(0.8, startCycleTeleport)
    end
end)
-- ====================== NEW: BRING PLAYER FEATURE ======================
PlayerlistBox:AddButton("Bring Selected Player", function()
    local sel = SelectedPlayerDropdown.Value
    if not sel or not player.Character then
        return
    end
    local targetPlr = getPlayerFromString(sel)
    if not targetPlr or not targetPlr.Character then
        return
    end
    if table.find(ignoredPlayers, targetPlr) then
        return
    end
    local targetRoot = targetPlr.Character:FindFirstChild("HumanoidRootPart")
    local myRoot = player.Character:FindFirstChild("HumanoidRootPart")
    if not targetRoot or not myRoot then
        return
    end
    local originalCFrame = myRoot.CFrame
    myRoot.CFrame = targetRoot.CFrame * CFrame.new(0, 0, 4)
    task.wait(0.1)
    slamEnabled = true
    if not slamLoop then
        slamLoop = task.spawn(function()
            while slamEnabled do
                local target = getSlamTarget()
                if target then fireSlam(target) end
                task.wait(slamSpeed)
            end
        end)
    end
    task.delay(0.3, function()
        if myRoot and myRoot.Parent then
            myRoot.CFrame = originalCFrame
        end
    end)
end)
-- ====================== ANTI-VOID BOUNCE (CLEAN & SILENT) ======================
local AntiVoidBounceEnabled = false
local AntiVoidConnection = nil
local VoidYLevel = -100
local BouncePower = 300
local function EnableAntiVoidBounce()
    if AntiVoidBounceEnabled then return end
    AntiVoidBounceEnabled = true
    Library:Notify("Anti-Void Bounce: ON (Y â‰¤ "..VoidYLevel..")", 5)
    AntiVoidConnection = RunService.Heartbeat:Connect(function()
        if not AntiVoidBounceEnabled or not player.Character then return end
        local hrp = player.Character:FindFirstChild("HumanoidRootPart")
        local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
        if not hrp or not humanoid or humanoid.Health <= 0 then return end
        if hrp.Position.Y <= VoidYLevel then
            -- Silent epic bounce
            hrp.Velocity = Vector3.new(hrp.Velocity.X * 0.8, BouncePower, hrp.Velocity.Z * 0.8)
            hrp.RotVelocity = Vector3.new(math.random(-30,30), math.random(40,60), math.random(-30,30))
            -- Boing sound + particles (still there, but no spam notify)
            local sound = Instance.new("Sound")
            sound.SoundId = "rbxassetid://6765005949"
            sound.Volume = 2
            sound.PlaybackSpeed = 0.9
            sound.Parent = hrp
            sound:Play()
            task.delay(2, function() sound:Destroy() end)
            local p = Instance.new("ParticleEmitter", hrp)
            p.Texture = "rbxassetid://241353019"
            p.LightEmission = 1
            p.Color = ColorSequence.new(Color3.fromRGB(0, 255, 255))
            p.Rate = 1000
            p.Lifetime = NumberRange.new(0.6)
            p.Speed = NumberRange.new(60, 100)
            p.SpreadAngle = Vector2.new(360, 360)
            p.Transparency = NumberSequence.new(0, 1)
            p.Size = NumberSequence.new(2, 0)
            task.delay(0.7, function() p:Destroy() end)
        end
    end)
end
local function DisableAntiVoidBounce()
    AntiVoidBounceEnabled = false
    if AntiVoidConnection then AntiVoidConnection:Disconnect() AntiVoidConnection = nil end
    Library:Notify("Anti-Void Bounce: OFF", 3)
end
player.CharacterAdded:Connect(function()
    task.wait(1)
    if AntiVoidBounceEnabled then EnableAntiVoidBounce() end
end)
-- UI
local AntiVoidBox = Tabs.Misc:AddRightGroupbox("Anti-Void Bounce")
AntiVoidBox:AddToggle("AntiVoidBounceToggle", {
    Text = "Enable",
    Default = false,
    Callback = function(v)
        if v then EnableAntiVoidBounce() else DisableAntiVoidBounce() end
    end
})
AntiVoidBox:AddSlider("VoidYLevel", {
    Text = "Void Y Level",
    Min = -500, Max = 100, Default = -100, Rounding = 1,
    Suffix = " studs",
    Callback = function(v) VoidYLevel = v end
})
-- ====================== GLOBAL CHAT SPOOFER (EVERYONE SEES IT) ======================
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local player = Players.LocalPlayer -- This will be whoever runs the script
local function SendGlobalChat(message, speakerName)
    speakerName = speakerName or player.Name -- Uses the actual name of whoever is running it
    -- Legacy chat system
    pcall(function()
        ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer(message, "All")
    end)
    -- Custom Communicate.Chat remote
    pcall(function()
        local chatRemote = ReplicatedStorage:FindFirstChild("Communicate", true)
        if chatRemote and chatRemote:FindFirstChild("Chat") then
            chatRemote.Chat:FireServer("ChatMessage", speakerName, message, "", "Player", true, player)
        end
    end)
    -- New TextChatService (modern games)
    pcall(function()
        game:GetService("TextChatService").TextChannels.RBXGeneral:SendAsync(message)
    end)
end
local ChatBox = Tabs.Misc:AddRightGroupbox("Global Chat")
local ChatInput = ChatBox:AddInput("ChatMessageInput", {
    Default = "gg",
    Text = "Message",
})
ChatBox:AddButton("Send Chat", function()
    local msg = ChatInput.Value
    if msg:gsub(" ", "") ~= "" then
        SendGlobalChat(msg, player.Name) -- Everyone appears as themselves
    end
end)
-- ====================== NOCLIP ======================
local NoclipEnabled = false
local NoclipConnection = nil
local OriginalCollision = {}
local PartsCache = {} -- Cache for quick access to character parts
local function UpdatePartsCache(char)
    PartsCache = {}
    if char then
        for _, part in pairs(char:GetDescendants()) do
            if part:IsA("BasePart") then
                table.insert(PartsCache, part)
            end
        end
    end
end
local function SaveCollision(char)
    OriginalCollision = {}
    UpdatePartsCache(char)
    for _, part in ipairs(PartsCache) do
        OriginalCollision[part] = part.CanCollide
    end
end
local function RestoreCollision()
    for part, state in pairs(OriginalCollision) do
        if part and part.Parent then
            pcall(function() part.CanCollide = state end)
        end
    end
    OriginalCollision = {}
    PartsCache = {}
end
local function EnableNoclip()
    if NoclipEnabled then return end
    NoclipEnabled = true
    Library:Notify("Noclip: ON", 3)
    local char = player.Character or player.CharacterAdded:Wait()
    SaveCollision(char)
    -- Use Heartbeat instead of Stepped for slightly better performance
    -- Directly use cached parts table to avoid repeated GetDescendants calls
    NoclipConnection = game:GetService("RunService").Heartbeat:Connect(function()
        if not NoclipEnabled or not player.Character then return end
        for _, part in ipairs(PartsCache) do
            if part and part.Parent then -- Extra safety check
                part.CanCollide = false
            end
        end
    end)
end
local function DisableNoclip()
    if not NoclipEnabled then return end
    NoclipEnabled = false
    Library:Notify("Noclip: OFF", 3)
    if NoclipConnection then
        NoclipConnection:Disconnect()
        NoclipConnection = nil
    end
    RestoreCollision()
end
player.CharacterAdded:Connect(function(char)
    task.wait(0.8)
    UpdatePartsCache(char) -- Refresh cache on respawn
    if NoclipEnabled then
        SaveCollision(char)
        EnableNoclip() -- Reconnect with updated cache
    end
end)
local NoclipBox = Tabs.Misc:AddLeftGroupbox("Noclip")
NoclipBox:AddToggle("NoclipToggle", {Text = "Enable", Default = false, Callback = function(v)
    if v then EnableNoclip() else DisableNoclip() end
end})
-- ====================== WALKSPEED (DEDICATED BOX - FULLY WORKING) ======================
local WalkspeedEnabled = false
local CurrentWalkSpeed = 100
local DefaultWalkSpeed = 16
local function ApplyWalkSpeed()
    if player.Character and player.Character:FindFirstChildOfClass("Humanoid") then
        local hum = player.Character.Humanoid
        hum.WalkSpeed = WalkspeedEnabled and CurrentWalkSpeed or DefaultWalkSpeed
    end
end
-- Re-apply on respawn/death
player.CharacterAdded:Connect(function()
    task.wait(1)
    if WalkspeedEnabled then
        ApplyWalkSpeed()
    end
end)
-- Create its own beautiful box under Noclip
local WalkspeedBox = Tabs.Misc:AddLeftGroupbox("Walkspeed")
WalkspeedBox:AddToggle("WalkspeedToggle", {
    Text = "Enable",
    Default = false,
    Callback = function(state)
        WalkspeedEnabled = state
        ApplyWalkSpeed()
        Library:Notify("Walkspeed " .. (state and ("ON â†’ " .. CurrentWalkSpeed) or "OFF"), 4)
    end
})
WalkspeedBox:AddSlider("WalkspeedSlider", {
    Text = "Speed",
    Min = 16,
    Max = 500,
    Default = 100,
    Rounding = 1,
    Suffix = " studs/s",
    Callback = function(value)
        CurrentWalkSpeed = value
        if WalkspeedEnabled then
            ApplyWalkSpeed()
            Library:Notify("Walkspeed â†’ " .. value, 2)
        end
    end
})
-- ====================== WALK FLING (INFINITE YIELD STYLE - WORKING DEC 2025) ======================
local WalkFling = {
    Enabled = false;
    Connection = nil;
    NoclipConnection = nil;
}
local function EnableWalkFling()
    if WalkFling.Enabled then return end
    WalkFling.Enabled = true
    Library:Notify("Walk Fling: ON", 6)
    local char = player.Character or player.CharacterAdded:Wait()
    local root = char:WaitForChild("HumanoidRootPart")
    -- Auto-enable noclip (prevents you from getting stuck/flung yourself)
    WalkFling.NoclipConnection = game:GetService("RunService").Stepped:Connect(function()
        if not WalkFling.Enabled then return end
        for _, part in ipairs(char:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
            end
        end
    end)
    -- Main fling loop (exact IY logic, proven working in 2025)
    WalkFling.Connection = game:GetService("RunService").Heartbeat:Connect(function()
        if not WalkFling.Enabled or not char.Parent or not root.Parent then return end
        local vel = root.Velocity
        local movel = 0.1
        -- Massive velocity spike
        root.Velocity = vel * 10000 + Vector3.new(0, 10000, 0)
        game:GetService("RunService").RenderStepped:Wait()
        if root.Parent then
            root.Velocity = vel -- Quick reset
        end
        game:GetService("RunService").Stepped:Wait()
        if root.Parent then
            root.Velocity = vel + Vector3.new(0, movel, 0)
            movel = movel * -1 -- Tiny oscillation for stability
        end
    end)
    -- Auto-reenable on respawn
    player.CharacterAdded:Connect(function(newChar)
        if WalkFling.Enabled then
            task.wait(1)
            char = newChar
            root = char:WaitForChild("HumanoidRootPart")
        end
    end)
end
local function DisableWalkFling()
    WalkFling.Enabled = false
    if WalkFling.Connection then
        WalkFling.Connection:Disconnect()
        WalkFling.Connection = nil
    end
    if WalkFling.NoclipConnection then
        WalkFling.NoclipConnection:Disconnect()
        WalkFling.NoclipConnection = nil
    end
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        player.Character.HumanoidRootPart.Velocity = Vector3.zero
        -- Re-enable collisions
        for _, part in ipairs(player.Character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = true
            end
        end
    end
    Library:Notify("Walk Fling: OFF", 3)
end
-- UI Box - Placed under Walkspeed on LEFT side
local WalkFlingBox = Tabs.Misc:AddLeftGroupbox("Walk Fling")
WalkFlingBox:AddToggle("WalkFlingToggle", {
    Text = "Enable Walk Fling",
    Default = false,
    Tooltip = "Self Explanatory",
    Callback = function(v)
        if v then EnableWalkFling() else DisableWalkFling() end
    end
})
-- ====================== ANTI-FLING (CLEAN VERSION - NO AURA BREAKER TOGGLE HERE) ======================
local AntiFlingEnabled = false
local AntiFlingConnection = nil
local WasAnchored = false
local AntiOtherFlingConnection = nil
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local player = Players.LocalPlayer
-- cache of other players' HRPs (NO workspace scanning)
local OtherHRPs = {}
local function CacheHRP(plr)
    if plr == player then return end
    local function OnCharacter(char)
        local hrp = char:WaitForChild("HumanoidRootPart", 5)
        if hrp then
            OtherHRPs[plr] = hrp
        end
    end
    if plr.Character then
        OnCharacter(plr.Character)
    end
    plr.CharacterAdded:Connect(OnCharacter)
    plr.CharacterRemoving:Connect(function()
        OtherHRPs[plr] = nil
    end)
end
-- build cache
for _, plr in ipairs(Players:GetPlayers()) do
    CacheHRP(plr)
end
Players.PlayerAdded:Connect(CacheHRP)
Players.PlayerRemoving:Connect(function(plr)
    OtherHRPs[plr] = nil
end)
-- === YOUR ORIGINAL SCRIPT (UNCHANGED BEHAVIOR) ===
local function EnableAntiFling()
    if AntiFlingEnabled then return end
    AntiFlingEnabled = true
    -- self protection (your original)
    AntiFlingConnection = RunService.Heartbeat:Connect(function()
        if not AntiFlingEnabled or not player.Character then return end
        local root = player.Character:FindFirstChild("HumanoidRootPart")
        local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
        if not root or not humanoid or humanoid.Health <= 0 then return end
        local vel = root.AssemblyLinearVelocity.Magnitude
        local rotVel = root.AssemblyAngularVelocity.Magnitude
        if vel > 180 or rotVel > 100 then
            root.AssemblyLinearVelocity = Vector3.zero
            root.AssemblyAngularVelocity = Vector3.zero
            if not root.Anchored then
                WasAnchored = true
                root.Anchored = true
                task.delay(0.05, function()
                    if root and root.Parent and AntiFlingEnabled then
                        root.Anchored = false
                    end
                end)
            end
            if humanoid:GetState() == Enum.HumanoidStateType.Ragdoll then
                humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
            end
        elseif root.Anchored and WasAnchored then
            root.Anchored = false
            WasAnchored = false
        end
    end)
    -- anti-fling others (LAG-FREE)
    AntiOtherFlingConnection = RunService.Heartbeat:Connect(function()
        if not AntiFlingEnabled then return end
        for _, hrp in pairs(OtherHRPs) do
            if hrp and hrp.Parent and not hrp.Anchored then
                hrp.CustomPhysicalProperties = PhysicalProperties.new(0,0,0,0,0)
                hrp.AssemblyLinearVelocity = Vector3.zero
                hrp.AssemblyAngularVelocity = Vector3.zero
                hrp.CanCollide = false
            end
        end
    end)
end
local function DisableAntiFling()
    AntiFlingEnabled = false
    if AntiFlingConnection then
        AntiFlingConnection:Disconnect()
        AntiFlingConnection = nil
    end
    if AntiOtherFlingConnection then
        AntiOtherFlingConnection:Disconnect()
        AntiOtherFlingConnection = nil
    end
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        player.Character.HumanoidRootPart.Anchored = false
    end
end
player.CharacterAdded:Connect(function()
    task.wait(1)
    if AntiFlingEnabled then EnableAntiFling() end
end)
local AntiFlingBox = Tabs.Misc:AddRightGroupbox("Anti-Fling")
AntiFlingBox:AddToggle("AntiFlingToggle", {
    Text = "Enable Anti-Fling",
    Default = false,
    Tooltip = "Don't get flinged by others.",
    Callback = function(v)
        if v then EnableAntiFling() else DisableAntiFling() end
    end
})
-- ====================== KILL AURA BREAKER (DEDICATED BOX UNDER ANTI-FLING) ======================
local AuraBreakerEnabled = false
local AuraBreakerConnection = nil
local AuraBreakerHeight = 17857143 -- ~5 million meters in studs
local SavedGroundPosition = nil
local function TeleportSky()
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return end
    local root = player.Character.HumanoidRootPart
    local newY = root.Position.Y + AuraBreakerHeight
    root.CFrame = CFrame.new(root.Position.X, newY, root.Position.Z)
end
local function TeleportBackToGround()
    if not SavedGroundPosition or not player.Character then return end
    local root = player.Character:FindFirstChild("HumanoidRootPart")
    if root then
        root.CFrame = CFrame.new(SavedGroundPosition)
        root.Velocity = Vector3.new(0, 0, 0) -- Prevent any bounce or upward momentum
        root.RotVelocity = Vector3.new(0, 0, 0)
    end
end
local function EnableAuraBreaker()
    if AuraBreakerEnabled then
        -- Already on â†’ just go back up
        TeleportSky()
        return
    end
    AuraBreakerEnabled = true
    -- Save ground position
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        SavedGroundPosition = player.Character.HumanoidRootPart.Position
    end
    TeleportSky()
    -- Fling protection loop
    AuraBreakerConnection = RunService.Heartbeat:Connect(function()
        if not AuraBreakerEnabled or not player.Character then return end
        local root = player.Character:FindFirstChild("HumanoidRootPart")
        local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
        if not root or not humanoid or humanoid.Health <= 0 then return end
        local vel = root.Velocity.Magnitude
        local rotVel = root.RotVelocity.Magnitude
        if vel > 180 or rotVel > 100 then
            TeleportSky()
        end
    end)
end
local function DisableAuraBreaker()
    if not AuraBreakerEnabled then return end
    AuraBreakerEnabled = false
    if AuraBreakerConnection then
        AuraBreakerConnection:Disconnect()
        AuraBreakerConnection = nil
    end
    TeleportBackToGround()
end
-- No auto-reactivation on respawn
player.CharacterAdded:Connect(function()
    task.wait(1)
    -- Intentionally do nothing
end)
local AuraBreakerBox = Tabs.Misc:AddRightGroupbox("Kill Aura Breaker")
AuraBreakerBox:AddToggle("AuraBreakerToggle", {
    Text = "Enable",
    Default = false,
    Callback = function(v)
        if v then EnableAuraBreaker() else DisableAuraBreaker() end
    end
})
-- ====================== VARIABLES ======================
local hitboxConnection, speedConnection, auraLoop, slamLoop, weaveLoop
local autoRespawnEnabled = false
local selectedSpawnCFrame = nil
local respawnConnection = nil
local followConnection = nil
local advancedFollowConnection = nil
local targetKillPlayer = nil
local killTargetLoop = nil
local followDistance = 3
local TeleportDelay = 0.04
local KillDelay = 0.18
local godFarmingActive = false
local godFarmingLoop = nil
local godFarmIgnoreFriends = true
getgenv().KillTargetFollow = true
local Spawns = {
    Cafe = CFrame.new(-141.009765, 8.55477691, 40.662308),
    MainHallways = CFrame.new(-61.659660, 3.555050, 66.527390)
}
local function autoEquipFist()
    if not player.Character then return end
    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end
    humanoid:UnequipTools()
    task.wait(0.05)
    local fightTool = player.Backpack:FindFirstChild("Fight") or player.Character:FindFirstChild("Fight")
    if fightTool then humanoid:EquipTool(fightTool) end
end
local function enableAutoRespawn()
    if respawnConnection then respawnConnection:Disconnect() end
    respawnConnection = player.CharacterAdded:Connect(function(char)
        if not autoRespawnEnabled or not selectedSpawnCFrame then return end
        task.wait(0.35)
        local hrp = char:FindFirstChild("HumanoidRootPart") or char:WaitForChild("HumanoidRootPart", 5)
        if hrp then hrp.CFrame = selectedSpawnCFrame end
    end)
end
local function disableAutoRespawn()
    if respawnConnection then respawnConnection:Disconnect() respawnConnection = nil end
end
local function startKillTarget(plr)
    if killTargetLoop then task.cancel(killTargetLoop) end
    targetKillPlayer = plr
    killTargetLoop = task.spawn(function()
        while task.wait(0.03) do
            if not targetKillPlayer or not targetKillPlayer.Character or not player.Character then break end
            local core = player.Character:FindFirstChild("Core")
            if not core then break end
            local comm = core:FindFirstChild("Communicate")
            if not comm then break end
            local remote = comm:FindFirstChildWhichIsA("RemoteEvent") or comm:FindFirstChild("blank")
            if not remote then break end
            local head = targetKillPlayer.Character:FindFirstChild("Head")
            local root = targetKillPlayer.Character:FindFirstChild("HumanoidRootPart")
            if head and root then
                for i = 1,4 do
                    remote:FireServer("Swing")
                    remote:FireServer("Attack", {Character = targetKillPlayer.Character, Point = root.Position, Hit = head, Limb = "Head"}, false)
                end
                if getgenv().KillTargetFollow then
                    local myRoot = player.Character:FindFirstChild("HumanoidRootPart")
                    if myRoot then myRoot.CFrame = root.CFrame * CFrame.new(0,0,2.5) end
                end
            end
        end
    end)
end
local function stopKillTarget()
    if killTargetLoop then task.cancel(killTargetLoop) killTargetLoop = nil end
    targetKillPlayer = nil
end
-- ====================== PLAYERLIST FEATURES ======================
PlayerlistBox:AddToggle("BasicFollow", {Text = "Basic Follow (1.2 studs)", Default = false, Callback = function(state)
    local sel = SelectedPlayerDropdown.Value
    if not sel then Library:Notify("Select a player first!", 3) return end
    local targetPlr = getPlayerFromString(sel)
    if not targetPlr then return end
    if state then
        if followConnection then followConnection:Disconnect() end
        followConnection = RunService.Heartbeat:Connect(function()
            if player.Character and targetPlr.Character then
                local myRoot = player.Character.HumanoidRootPart
                local tRoot = targetPlr.Character.HumanoidRootPart
                if myRoot and tRoot then myRoot.CFrame = tRoot.CFrame * CFrame.new(0,0,1.2) end
            end
        end)
        Library:Notify("Following "..targetPlr.DisplayName, 4)
    else
        if followConnection then followConnection:Disconnect() followConnection = nil end
        Library:Notify("Stopped following", 3)
    end
end})
PlayerlistBox:AddButton("Teleport to Selected", function()
    local sel = SelectedPlayerDropdown.Value
    if not sel or not player.Character then return end
    local targetPlr = getPlayerFromString(sel)
    if targetPlr and targetPlr.Character then
        player.Character.HumanoidRootPart.CFrame = targetPlr.Character.HumanoidRootPart.CFrame * CFrame.new(0,0,-2)
        Library:Notify("Teleported to "..targetPlr.DisplayName, 4)
    end
end)
SettingsBox:AddToggle("KillTargetFollow", {Text = "Kill Target + Follow", Default = true, Callback = function(v) getgenv().KillTargetFollow = v end})
SettingsBox:AddSlider("FollowDistance", {Text = "Follow Distance", Default = 3, Min = 1, Max = 30, Rounding = 1, Suffix = " studs", Callback = function(v) followDistance = v end})
SettingsBox:AddToggle("AdvancedFollow", {Text = "Advanced Follow Bot", Default = false, Callback = function(state)
    local sel = SelectedPlayerDropdown.Value
    if not sel then Library:Notify("Select a player!", 3) return end
    local targetPlr = getPlayerFromString(sel)
    if not targetPlr then return end
    if state then
        if advancedFollowConnection then advancedFollowConnection:Disconnect() end
        advancedFollowConnection = RunService.Heartbeat:Connect(function()
            if player.Character and targetPlr.Character then
                local myRoot = player.Character.HumanoidRootPart
                local tRoot = targetPlr.Character.HumanoidRootPart
                if myRoot and tRoot then myRoot.CFrame = tRoot.CFrame * CFrame.new(0,0,followDistance) end
            end
        end)
        Library:Notify("Advanced following "..targetPlr.DisplayName.." from "..followDistance.." studs", 5)
    else
        if advancedFollowConnection then advancedFollowConnection:Disconnect() advancedFollowConnection = nil end
        Library:Notify("Stopped advanced follow", 3)
    end
end})
SettingsBox:AddButton("KILL TARGET", function()
    local sel = SelectedPlayerDropdown.Value
    if not sel then Library:Notify("Select a player!", 3) return end
    local targetPlr = getPlayerFromString(sel)
    if not targetPlr then return end
    if table.find(ignoredPlayers, targetPlr) then
        Library:Notify(targetPlr.DisplayName.." is ignored!", 3)
    else
        autoEquipFist()
        startKillTarget(targetPlr)
        Library:Notify("Now killing "..targetPlr.DisplayName, 5)
    end
end)
SettingsBox:AddButton("Stop Kill Target", stopKillTarget)
-- ====================== PARTY INVITE FEATURE (INTEGRATED INTO PLAYERLIST) ======================
local function getPartyRemote(plr)
    plr = plr or player
    return plr:FindFirstChild("Communicate")
        and plr.Communicate:FindFirstChild("Interface")
        and plr.Communicate.Interface:FindFirstChild("RemoteEvent")
end
local partyRemote = getPartyRemote()
local function forceJoinPlayer(targetPlr)
    if not targetPlr then return end
    local targetRemote = getPartyRemote(targetPlr)
    if not targetRemote then return end
    pcall(function()
        -- Send invite instantly
        partyRemote:FireServer("InviteToParty", targetPlr)
        -- Immediately force accept from target's side (no visible delay or prompt in compatible games)
        targetRemote:FireServer("AcceptInvite")
        targetRemote:FireServer("AcceptPartyInvite")
        targetRemote:FireServer("JoinParty")
        targetRemote:FireServer("JoinParty", player.UserId)
        targetRemote:FireServer("JoinParty", player)
    end)
end
PlayerlistBox:AddButton("Force into party", function()
    if not partyRemote then
        return
    end
    local sel = SelectedPlayerDropdown.Value
    if not sel then
        return
    end
    local targetPlr = getPlayerFromString(sel)
    if not targetPlr then
        return
    end
    forceJoinPlayer(targetPlr)
end)
PlayerlistBox:AddButton("Force all players into the party", function()
    if not partyRemote then
        return
    end
    for _, plr in Players:GetPlayers() do
        if plr ~= player then
            forceJoinPlayer(plr)
            task.wait(0.1)
        end
    end
end)
player.CharacterAdded:Connect(function()
    task.wait(2)
    partyRemote = getPartyRemote()
end)
-- ====================== AUTO RESPECT FARM (UPDATED: 6 PADS FOR MULTI-PLAYER) ======================
local respectFarmEnabled = false
local respectFarmLoop = nil
local respectPositions = {
    Vector3.new(-118.117615, 3.554776, -12.154626), -- Pad 1
    Vector3.new(-112.016205, 3.554777, -12.118540), -- Pad 2
    Vector3.new(-144.176865, 3.554777, -11.715694), -- Pad 3
    Vector3.new(-150.178680, 3.554776, -11.174050), -- Pad 4
    Vector3.new(-176.547165, 3.554777, -11.993616), -- Pad 5
    Vector3.new(-182.240021, 3.554777, -12.553525) -- Pad 6
}
-- Choose which pad you will farm at (toggle in UI)
local myRespectPositionIndex = 1 -- 1 = Pad 1, etc.
local function startRespectFarm()
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return end
    local hrp = player.Character.HumanoidRootPart
    local targetPos = respectPositions[myRespectPositionIndex]
    hrp.CFrame = CFrame.new(targetPos)
end
local function enableRespectFarm()
    if respectFarmEnabled then return end
    respectFarmEnabled = true
    respectFarmLoop = task.spawn(function()
        while respectFarmEnabled do
            if myRespectPositionIndex == 2 or myRespectPositionIndex == 3 or myRespectPositionIndex == 5 then
                -- For Pad 2, 3, and 5: Teleport to pad, farm for 2 seconds, then auto-kill to force respawn/reset
                startRespectFarm()
                task.wait(2)
                local char = player.Character
                if char then
                    local hum = char:FindFirstChildOfClass("Humanoid")
                    if hum then
                        hum.Health = 0
                    end
                end
            else
                -- Normal fast teleport for all other pads (1, 4, 6)
                startRespectFarm()
                task.wait(0.4)
            end
        end
    end)
end
local function disableRespectFarm()
    respectFarmEnabled = false
    if respectFarmLoop then
        task.cancel(respectFarmLoop)
        respectFarmLoop = nil
    end
end
player.CharacterAdded:Connect(function()
    task.wait(1)
    if respectFarmEnabled then
        enableRespectFarm()
    end
end)
-- UI for Respect Farm in Farming tab (6 pad selector)
local RespectFarmBox = Tabs.Farming:AddRightGroupbox("Auto Respect Farm")
RespectFarmBox:AddLabel("Choose your pad:")
RespectFarmBox:AddDropdown("RespectPosition", {
    Values = {"Pad 1", "Pad 2", "Pad 3", "Pad 4", "Pad 5", "Pad 6"},
    Default = "Pad 1",
    Callback = function(value)
        myRespectPositionIndex = tonumber(value:match("Pad (%d+)"))
        -- Instantly teleport if already farming
        if respectFarmEnabled then
            startRespectFarm()
        end
    end
})
RespectFarmBox:AddToggle("RespectFarmToggle", {
    Text = "Enable Auto Respect Farm",
    Default = false,
    Callback = function(state)
        if state then
            enableRespectFarm()
        else
            disableRespectFarm()
        end
    end
})
-- ====================== GOD FARMING ======================
local FarmingBox = Tabs.Farming:AddLeftGroupbox("Auto Farm")
FarmingBox:AddToggle("GodFarmingMode", {Text = "Enable", Default = false, Tooltip = "Kills everyone (respects ignore + friends)", Callback = function(state)
    godFarmingActive = state
    if state then
        autoEquipFist()
        Library:Notify("GOD FARMING ACTIVATED", 10)
        if godFarmingLoop then task.cancel(godFarmingLoop) end
        godFarmingLoop = task.spawn(function()
            while godFarmingActive do
                if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then task.wait(0.5) continue end
                local hrp = player.Character.HumanoidRootPart
                for _, target in Players:GetPlayers() do
                    if target == player or table.find(ignoredPlayers, target) then continue end
                    if godFarmIgnoreFriends and player:IsFriendsWith(target.UserId) then continue end
                    if not target.Character or not target.Character:FindFirstChild("Head") then continue end
                    local tRoot = target.Character.HumanoidRootPart
                    hrp.CFrame = tRoot.CFrame * CFrame.new(0,0,2.5)
                    task.wait(TeleportDelay)
                    startKillTarget(target)
                    task.wait(KillDelay)
                end
                task.wait(0.1)
            end
        end)
    else
        if godFarmingLoop then task.cancel(godFarmingLoop) godFarmingLoop = nil end
        stopKillTarget()
        Library:Notify("GOD FARMING DEACTIVATED", 5)
    end
end})
FarmingBox:AddToggle("GodFarmIgnoreFriends", {Text = "Ignore Friends", Default = true, Callback = function(v) godFarmIgnoreFriends = v end})
FarmingBox:AddDivider() FarmingBox:AddLabel("Speed Control", true)
FarmingBox:AddSlider("TeleportDelay", {Text = "Teleport Delay", Min = 0.001, Max = 1, Default = 0.04, Rounding = 3, Suffix = "s", Callback = function(v) TeleportDelay = v end})
FarmingBox:AddSlider("KillDelay", {Text = "Kill Delay", Min = 0.01, Max = 2, Default = 0.18, Rounding = 3, Suffix = "s", Callback = function(v) KillDelay = v end})
-- ====================== AUTOWEAVE ======================
local regularInterval = 0.3
local microInterval   = 0.012

local isWeaving = false
local legitMode = false

local normalLoop = nil
local legitLoop  = nil

local RunService = game:GetService("RunService")
local UIS        = game:GetService("UserInputService")
local player     = game.Players.LocalPlayer

local function fireWeave()
    local char = player.Character
    if not char or not char:FindFirstChild("Humanoid") then return end
   
    for _, v in char:GetChildren() do
        if v:IsA("LocalScript") and v:FindFirstChild("Communicate") then
            local remote = v.Communicate:FindFirstChildWhichIsA("RemoteEvent") 
                        or v.Communicate:FindFirstChild("blank")
            
            if remote then
                pcall(function()
                    remote:FireServer(nil, nil, true)
                end)
            end
        end
    end
end

local function fireWeaveAlt()
    local char = player.Character
    if not char or not char:FindFirstChild("Humanoid") then return end
   
    for _, v in char:GetChildren() do
        if v:IsA("LocalScript") and v:FindFirstChild("Communicate") then
            local remote = v.Communicate:FindFirstChildWhichIsA("RemoteEvent") 
                        or v.Communicate:FindFirstChild("blank")
            
            if remote then
                pcall(function()
                    remote:FireServer("Weave", nil, false)
                end)
            end
        end
    end
end

local function waitWithHeartbeat(targetTime)
    local start = tick()
    while tick() - start < targetTime do
        RunService.Heartbeat:Wait()
    end
end

-- Normal mode: fast auto-weave with micro speed boost
local function startNormal()
    if normalLoop then task.cancel(normalLoop) end
    
    normalLoop = task.spawn(function()
        while isWeaving do
            fireWeaveAlt()
            RunService.Heartbeat:Wait()
            fireWeave()
            
            local variation = math.random(-12, 12) / 1000
            local totalDelay = math.max(0.01, regularInterval - microInterval + variation)
            waitWithHeartbeat(totalDelay)
        end
    end)
end

-- Legit mode: uses regularInterval to control weave speed while holding
local function startLegit()
    if legitLoop then task.cancel(legitLoop) end
    
    legitLoop = task.spawn(function()
        local wasPressed = false
        
        while isWeaving do
            local currentlyPressed = UIS:IsMouseButtonPressed(Enum.UserInputType.MouseButton1)
            
            if currentlyPressed then
                if not wasPressed then
                    -- Quick initial burst on first press
                    fireWeaveAlt()
                    task.wait(0.0)
                    fireWeave()
                    task.wait(0.0)
                    fireWeave()
                    wasPressed = true
                else
                    -- Main hold pattern paced by regularInterval
                    fireWeaveAlt()
                    RunService.Heartbeat:Wait()  -- small safety gap
                    fireWeave()
                    
                    local variation = math.random(-25, 25) / 1000
                    waitWithHeartbeat(regularInterval + variation)
                end
            else
                wasPressed = false
                RunService.Heartbeat:Wait()
            end
        end
    end)
end

local function stopWeave()
    if normalLoop then
        task.cancel(normalLoop)
        normalLoop = nil
    end
    if legitLoop then
        task.cancel(legitLoop)
        legitLoop = nil
    end
end

local function startWeave()
    stopWeave()
    
    if legitMode then
        startLegit()
    else
        startNormal()
    end
end

-- Restart on respawn/reset
player.CharacterAdded:Connect(function(newChar)
    task.wait(1.8)
    if isWeaving and player.Character == newChar then
        startWeave()
    end
end)

local CombatBox = Tabs.Combat:AddLeftGroupbox("Autoweave")

CombatBox:AddToggle("AutoweaveToggle", {
    Text = "Enable Autoweave",
    Default = false,
    Callback = function(v)
        isWeaving = v
        if v then
            startWeave()
        else
            stopWeave()
        end
    end
})

CombatBox:AddToggle("AutoweaveLegitMode", {
    Text = "Autoweave Legit Mode",
    Default = false,
    Callback = function(v)
        legitMode = v
        if isWeaving then
            startWeave()
        end
    end
})

CombatBox:AddSlider("RegularInterval", {
    Text = "Weave Interval",
    Default = 0.3,
    Min = 0.01,
    Max = 0.5,
    Rounding = 3,
    Suffix = "s",
    Callback = function(v)
        regularInterval = v
    end
})

CombatBox:AddSlider("MicroInterval", {
    Text = "Micro Weave Interval",
    Default = 0.0008,
    Min = 0.0002,
    Max = 0.05,
    Rounding = 5,
    Suffix = "s",
    Callback = function(v)
        microInterval = v
    end
})
-- ====================== HITBOX EXPANDER ======================
getgenv().HitboxEnabled = false
getgenv().HitboxSize = 5
getgenv().HitboxTransparency = 0.7
local HitboxBox = Tabs.Combat:AddRightGroupbox("Hitbox Expander")
HitboxBox:AddToggle("HitboxToggle", {Text = "Enable Hitbox Expander", Default = false, Callback = function(state)
    getgenv().HitboxEnabled = state
    if state then
        hitboxConnection = RunService.RenderStepped:Connect(function()
            if not getgenv().HitboxEnabled then return end
            for _, plr in Players:GetPlayers() do
                if plr == player or not plr.Character then continue end
                local hrp = plr.Character:FindFirstChild("HumanoidRootPart")
                if hrp then
                    hrp.Size = Vector3.new(getgenv().HitboxSize, getgenv().HitboxSize, getgenv().HitboxSize)
                    hrp.Transparency = getgenv().HitboxTransparency
                    hrp.BrickColor = BrickColor.new("Really red")
                    hrp.Material = Enum.Material.Neon
                    hrp.CanCollide = false
                end
            end
        end)
        Library:Notify("Hitbox Expander ON", 3)
    else
        if hitboxConnection then hitboxConnection:Disconnect() hitboxConnection = nil end
        for _, plr in Players:GetPlayers() do
            if plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                local hrp = plr.Character.HumanoidRootPart
                hrp.Size = Vector3.new(2,2,1) hrp.Transparency = 1 hrp.Material = Enum.Material.Plastic
            end
        end
        Library:Notify("Hitbox Expander OFF", 3)
    end
end})
HitboxBox:AddSlider("HitboxSize", {Text="Size", Default=5, Min=2, Max=10, Rounding=1, Callback=function(v) getgenv().HitboxSize = v end})
HitboxBox:AddSlider("HitboxTransparency", {Text="Transparency", Default=0.7, Min=0, Max=1, Rounding=2, Callback=function(v) getgenv().HitboxTransparency = v end})
-- ====================== SPEED PUNCH ======================
local speedPunchEnabled = false
local speedMultiplier = 1  -- Changed default to 1 for better fine control
local SpeedPunchBox = Tabs.Combat:AddLeftGroupbox("Speed Punch")

SpeedPunchBox:AddToggle("SpeedPunchToggle", {
    Text = "Enable Speed Punch",
    Default = false,
    Callback = function(v)
        speedPunchEnabled = v
        if v then
            speedConnection = RunService.Heartbeat:Connect(function()
                local hum = player.Character and player.Character:FindFirstChildOfClass("Humanoid")
                if hum then
                    for _, track in hum:GetPlayingAnimationTracks() do
                        track:AdjustSpeed(speedMultiplier)
                    end
                end
            end)
        else
            if speedConnection then
                speedConnection:Disconnect()
                speedConnection = nil
            end
            local hum = player.Character and player.Character:FindFirstChildOfClass("Humanoid")
            if hum then
                for _, track in hum:GetPlayingAnimationTracks() do
                    track:AdjustSpeed(1)
                end
            end
        end
    end
}):AddKeyPicker("SpeedPunchKeybind", {
    Text = "",  -- Empty text for minimal/small keybind button
    Mode = "Toggle",
    Default = "None",
    SyncToggleState = true
})

SpeedPunchBox:AddSlider("SpeedPunchSlider", {
    Text = "Punch Speed",
    Default = 1,     -- Starts at normal speed
    Min = 1,         -- Minimum 1.0
    Max = 10,        -- Maximum 10.0
    Rounding = 1,    -- Steps of 0.1 (1.0, 1.1, 1.2, ..., 10.0)
    Callback = function(v)
        speedMultiplier = v
    end
})
-- ====================== KILL AURA ======================
local auraEnabled = false
local ignoreFriendsAura = false
local auraRange = 200  -- Default set to 200 studs
local auraSpeed = 0.05

local function getClosestPlayer()
    local closest, closestDist = nil, auraRange
    local myRoot = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if not myRoot then return nil end
    for _, plr in Players:GetPlayers() do
        if plr == player or not plr.Character then continue end
        if ignoreFriendsAura and player:IsFriendsWith(plr.UserId) then continue end
        local root = plr.Character:FindFirstChild("HumanoidRootPart")
        local hum = plr.Character:FindFirstChildOfClass("Humanoid")
        if root and hum then
            local dist = (myRoot.Position - root.Position).Magnitude
            if dist < closestDist then closest = plr closestDist = dist end
        end
    end
    return closest
end

local function firePunch(target)
    local core = player.Character and player.Character:FindFirstChild("Core")
    if not core then return end
    local comm = core:FindFirstChild("Communicate")
    if not comm then return end
    local remote = comm:FindFirstChildWhichIsA("RemoteEvent") or comm:FindFirstChild("blank")
    if not remote then return end
    local head = target.Character:FindFirstChild("Head")
    local root = target.Character:FindFirstChild("HumanoidRootPart")
    if head and root then
      
        for i = 1, 3 do
            remote:FireServer("Swing")
            remote:FireServer("Attack", {Character = target.Character, Point = root.Position, Hit = head, Limb = "Head"}, false)
        end
    end
end

local AuraBox = Tabs.Combat:AddRightGroupbox("Kill Aura")
AuraBox:AddToggle("AuraToggle", {Text = "Enable Kill Aura", Default = false, Callback = function(v)
    auraEnabled = v
    if v then
        auraLoop = task.spawn(function()
            while auraEnabled do
                local target = getClosestPlayer()
                if target then
                    firePunch(target)
                end
                task.wait(auraSpeed)
            end
        end)
    else
        if auraLoop then task.cancel(auraLoop) auraLoop = nil end
    end
end})
AuraBox:AddToggle("IgnoreFriendsAura", {Text = "Ignore Friends", Default = false, Callback = function(v) ignoreFriendsAura = v end})
AuraBox:AddSlider("AuraRange", {Text = "Range", Default = 200, Min = 10, Max = 200, Suffix = " studs", Callback = function(v) auraRange = v end})  -- Max now 200 as requested
AuraBox:AddSlider("AuraSpeed", {Text = "Attack Speed", Default = 0.05, Min = 0.01, Max = 0.3, Rounding = 3, Suffix = "s", Callback = function(v)
    auraSpeed = v
end})
-- ====================== ONE PUNCH AURA ======================
local onePunchEnabled = false
local onePunchIgnoreFriends = false
local onePunchRange = 30
local onePunchSpeed = 0.08
local onePunchLoop = nil
local function getClosestForOnePunch()
    local closest, closestDist = nil, onePunchRange
    local myRoot = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if not myRoot then return nil end
    for _, plr in Players:GetPlayers() do
        if plr == player or not plr.Character then continue end
        if onePunchIgnoreFriends and player:IsFriendsWith(plr.UserId) then continue end
        local root = plr.Character:FindFirstChild("HumanoidRootPart")
        local hum = plr.Character:FindFirstChildOfClass("Humanoid")
        if root and hum and hum.Health > 0 then
            local dist = (myRoot.Position - root.Position).Magnitude
            if dist < closestDist then
                closest = plr
                closestDist = dist
            end
        end
    end
    return closest
end
local function fireOnePunch(target)
    local core = player.Character and player.Character:FindFirstChild("Core")
    if not core then return end
    local comm = core:FindFirstChild("Communicate")
    if not comm then return end
    local remote = comm:FindFirstChildWhichIsA("RemoteEvent") or comm:FindFirstChild("blank")
    if not remote then return end
    local head = target.Character:FindFirstChild("Head")
    local root = target.Character:FindFirstChild("HumanoidRootPart")
    if head and root then
        for i = 1, 20 do
            remote:FireServer("Swing")
            remote:FireServer("Attack", {Character = target.Character, Point = root.Position, Hit = head, Limb = "Head"}, false)
        end
    end
end
local OnePunchBox = Tabs.Combat:AddRightGroupbox("One Punch Aura")
OnePunchBox:AddToggle("OnePunchToggle", {
    Text = "Enable One Punch Aura",
    Default = false,
    Callback = function(v)
        onePunchEnabled = v
        if v then
            onePunchLoop = task.spawn(function()
                while onePunchEnabled do
                    local target = getClosestForOnePunch()
                    if target then
                        fireOnePunch(target)
                    end
                    task.wait(onePunchSpeed)
                end
            end)
        else
            if onePunchLoop then task.cancel(onePunchLoop) onePunchLoop = nil end
        end
    end
})
OnePunchBox:AddToggle("OnePunchIgnoreFriends", {Text = "Ignore Friends", Default = false, Callback = function(v) onePunchIgnoreFriends = v end})
OnePunchBox:AddSlider("OnePunchRange", {
    Text = "Range",
    Default = 30,
    Min = 10,
    Max = 60,
    Suffix = " studs",
    Callback = function(v) onePunchRange = v end
})
OnePunchBox:AddSlider("OnePunchSpeed", {
    Text = "Punch Speed",
    Default = 0.08,
    Min = 0.08,
    Max = 0.5,
    Rounding = 3,
    Suffix = "s",
    Callback = function(v)
        onePunchSpeed = v
    end
})
-- ====================== AUTO SLAM ======================
local slamEnabled = false
local slamIgnoreFriends = true
local slamRange = 200
local slamSpeed = 0.01          -- â† changed to 0.01

local function getSlamTarget()
    local closest, closestDist = nil, slamRange
    local myRoot = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if not myRoot then return nil end
    
    for _, plr in Players:GetPlayers() do
        if plr == player or not plr.Character then continue end
        if slamIgnoreFriends and player:IsFriendsWith(plr.UserId) then continue end
        
        local root = plr.Character:FindFirstChild("HumanoidRootPart")
        local hum = plr.Character:FindFirstChildOfClass("Humanoid")
        
        if root and hum then
            local dist = (myRoot.Position - root.Position).Magnitude
            if dist < closestDist then
                closest = plr
                closestDist = dist
            end
        end
    end
    return closest
end

local function fireSlam(target)
    local core = player.Character and player.Character:FindFirstChild("Core")
    if not core then return end
    
    local comm = core:FindFirstChild("Communicate")
    if not comm then return end
    
    local remote = comm:FindFirstChildWhichIsA("RemoteEvent") or comm:FindFirstChild("blank")
    if not remote then return end
    
    local root = target.Character:FindFirstChild("HumanoidRootPart")
    local torso = target.Character:FindFirstChild("UpperTorso") or root
    
    if root then
        for i = 1, 3 do
            remote:FireServer("Slam", {
                Character = target.Character,
                Point = root.Position,
                Hit = torso,
                Limb = "",
                Result = nil
            })
        end
    end
end

local SlamBox = Tabs.Combat:AddLeftGroupbox("Auto Slam")

SlamBox:AddToggle("AutoSlamToggle", {
    Text = "Enable Auto Slam",
    Default = false,
    Callback = function(v)
        slamEnabled = v
        if v then
            slamLoop = task.spawn(function()
                while slamEnabled do
                    local target = getSlamTarget()
                    if target then fireSlam(target) end
                    task.wait(slamSpeed)
                end
            end)
            Library:Notify("Auto Slam ON", 3)
        else
            if slamLoop then task.cancel(slamLoop) slamLoop = nil end
            Library:Notify("Auto Slam OFF", 3)
        end
    end
})

SlamBox:AddToggle("SlamIgnoreFriends", {
    Text = "Ignore Friends",
    Default = true,
    Callback = function(v) slamIgnoreFriends = v end
})

SlamBox:AddSlider("SlamRange", {
    Text = "Range",
    Default = 200,
    Min = 10,
    Max = 200,
    Suffix = " studs",
    Callback = function(v) slamRange = v end
})

SlamBox:AddSlider("SlamSpeed", {
    Text = "Slam Speed",
    Default = 0.01,              -- â† also updated here
    Min = 0.01,
    Max = 0.3,
    Rounding = 3,
    Suffix = "s",
    Callback = function(v)
        slamSpeed = v
        Library:Notify("Auto Slam Speed â†’ " .. v .. "s", 2)
    end
})
-- ====================== SPAWN TAB ======================
local SpawnLeft = Tabs.Spawn:AddLeftGroupbox("Spawn Locations")
local SpawnDropdown = SpawnLeft:AddDropdown("AutoSpawnLocation", {
    Values = {"Cafe", "Main Hallways", "Locker Room"},
    Default = "Cafe",
    Text = "Auto-Respawn Location",
    Callback = function(v)
        if v == "Cafe" then
            selectedSpawnCFrame = Spawns.Cafe
        elseif v == "Main Hallways" then
            selectedSpawnCFrame = Spawns.MainHallways
        elseif v == "Locker Room" then
            selectedSpawnCFrame = CFrame.new(-22.740227, 3.555051, 58.058826)
        end
    end
})
SpawnLeft:AddToggle("AutoRespawnToggle", {
    Text = "Auto Spawn on Death",
    Default = false,
    Callback = function(state)
        autoRespawnEnabled = state
        if state then
            enableAutoRespawn()
            Library:Notify("Auto Spawn ON", 5)
        else
            disableAutoRespawn()
            Library:Notify("Auto Spawn OFF", 4)
        end
    end
})
-- ====================== FULL UNLOAD ======================
local function FullUnload()
    DisableNoclip()
    if followConnection then followConnection:Disconnect() end
    if advancedFollowConnection then advancedFollowConnection:Disconnect() end
    stopWeave()
    if auraLoop then auraLoop:Disconnect() end
    if slamLoop then task.cancel(slamLoop) end
    if hitboxConnection then hitboxConnection:Disconnect() end
    if speedConnection then speedConnection:Disconnect() end
    stopKillTarget()
    disableAutoRespawn()
    for _, plr in Players:GetPlayers() do
        if plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
            local hrp = plr.Character.HumanoidRootPart
            hrp.Size = Vector3.new(2,2,1) hrp.Transparency = 1 hrp.Material = Enum.Material.Plastic
        end
    end
    Library:Notify("Menu Fully Unloaded", 6)
end
-- ====================== CONFIG TAB ======================
local ConfigGroup = Tabs.Config:AddLeftGroupbox("Menu Config")
ConfigGroup:AddToggle("ShowKeybindList", {Text="Show Keybind List", Default=false, Callback=function(v) Library.KeybindFrame.Visible = v end})
ConfigGroup:AddToggle("CustomCursor", {Text="Custom Cursor", Default=true, Callback=function(v) Library.ShowCustomCursor = v end})
ConfigGroup:AddDropdown("NotifySide", {Values={"Left","Right"}, Default="Right", Text="Notification Side", Callback=function(v) Library:SetNotifySide(v) end})
ConfigGroup:AddDropdown("DPIScale", {Values={"50%","75%","100%","125%","150%","175%","200%"}, Default="100%", Text="UI Scale", Callback=function(v) Library:SetDPIScale(tonumber(v:gsub("%%",""))/100) end})
ConfigGroup:AddDivider()
ConfigGroup:AddLabel("Menu Keybind"):AddKeyPicker("MenuKeybind", {Default="RightControl", Text="Menu Toggle"})

-- REJOIN BUTTON ADDED HERE (ABOVE UNLOAD SCRIPT)
ConfigGroup:AddButton("Rejoin Server", function()
    Library:Notify("Rejoining server...", 3)
    game:GetService("TeleportService"):Teleport(game.PlaceId, player)
end)

ConfigGroup:AddButton("Unload Script", function() FullUnload() Library:Unload() end)

-- ====================== THEME & SAVE MANAGER ======================
ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({"MenuKeybind"})
ThemeManager:SetFolder("KJMenu2025")
SaveManager:SetFolder("KJMenu2025")
SaveManager:BuildConfigSection(Tabs.Config)
ThemeManager:ApplyToTab(Tabs.Config)
SaveManager:LoadAutoloadConfig()
Library.ToggleKeybind = Options.MenuKeybind
Library:Notify("KJ's Menu 2025 â€” Fully Loaded!\nReal-time Playerlist â€¢ God Farm â€¢ Everything Works\nEnjoy King", 30)
